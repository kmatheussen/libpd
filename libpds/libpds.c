/*
 * Copyright (c) 2013 Kjetil Matheussen
 *
 * BSD Simplified License.
 * For information on usage and redistribution, and for a DISCLAIMER OF ALL
 * WARRANTIES, see the file, "LICENSE.txt," in this distribution.
 *
 */


#include <dlfcn.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <stdbool.h>
#include <dirent.h>
#include <sys/time.h>
#include <errno.h>

#include "libpds.h"

#include "libpd_so.c"
#include "libpds_autogenerated.c"


typedef struct lib {
  struct lib *next;
  const char *org_filename;
  const char *copy_filename;  
  const char *classname;
  const char *symname;
} lib_t;

typedef struct searchpath {
  struct searchpath *next;
  const char *path;
} searchpath_t;


static char error_string[1024] = {0};

static char *get_unique_temp_string(char *ret, char *postfix){
  struct timeval my_timeval;
  gettimeofday(&my_timeval, NULL);

  sprintf(ret,"/tmp/libpd_%llu_%llu_%d_XXXXXX%s", (unsigned long long)my_timeval.tv_sec, (unsigned long long)my_timeval.tv_usec, rand(), postfix);
  return ret;
}

static bool write_libpd_so_to_tempfile(char *template){
  int fd = mkostemps(template, 3, S_IRUSR | S_IXUSR);
  int num_bytes = write(fd, libs_libpd_so, sizeof(libs_libpd_so));

  if (num_bytes!=sizeof(libs_libpd_so)){
    sprintf(error_string,"Couldn't create file %s.",template);
    return false;
  }

  close(fd);
  return true;
}

static bool write_file_to_tempfile(const char *filename, char *template){
  int fd_read  = open(filename, O_RDONLY, 0666);
  int fd_write = mkostemps(template, 3, S_IRUSR | S_IXUSR);

  //printf("copy %s to %s\n", filename, template);

  if(fd_read==-1 || fd_write==-1){
    sprintf(error_string, "Unable to make temporary copy of \"%s\" (%s)",filename,strerror(errno));
    return false;
  }

  char buf[4098];

  while(true){
    int num_bytes_read = read(fd_read, buf, sizeof(buf));
    if(num_bytes_read==0)
      break;
    int num_bytes_written = write(fd_write, buf, num_bytes_read);
    if(num_bytes_read==-1 || num_bytes_written==-1 || num_bytes_read != num_bytes_written){
      sprintf(error_string, "Unable to make temporary copy of \"%s\" (%s)",filename, strerror(errno));
      close(fd_write);
      close(fd_read);
      return false;
    }
  }
   
  close(fd_write);
  close(fd_read);
  return true;
}


static char *get_symname(const char *classname, char *symname){
  int i, hexmunge = 0;
  const char *nameptr;

  // copied from s_loader.c
  for (i = 0, nameptr = classname; i < MAXPDSTRING-7 && *nameptr; nameptr++)
    {
      char c = *nameptr;
      if ((c>='0' && c<='9') || (c>='A' && c<='Z')||
          (c>='a' && c<='z' )|| c == '_')
        {
          symname[i] = c;
          i++;
        }
      /* trailing tilde becomes "_tilde" */
        else if (c == '~' && nameptr[1] == 0)
          {
            strcpy(symname+i, "_tilde");
            i += strlen(symname+i);
          }
        else /* anything you can't put in a C symbol is sprintf'ed in hex */
        {
          sprintf(symname+i, "0x%02x", c);
          i += strlen(symname+i);
            hexmunge = 1;
        }
    }
  symname[i] = 0;
  if (hexmunge)
    {
      memmove(symname+6, symname, strlen(symname)+1);
      strncpy(symname, "setup_", 6);
    }
  else strcat(symname, "_setup");

  return symname;
}

// dac~.pd_linux -> dac~
// noteout.pd_linux -> noteout
char *get_classname(const char *filename, char *ret){
  char *extension = strrchr(filename, '.');
  strcpy(ret, filename);
  ret[strlen(ret)-strlen(extension)] = 0;
  return ret;
}

static bool in_libs(lib_t *libs, const char *classname){
  while(libs!=NULL) {
    if(!strcmp(libs->classname, classname))
      return true;
    libs=libs->next;
  }
  return false;
}

static bool add_libs(lib_t **libs, const char *dirname){
  DIR * dir_stream;
  struct dirent * dir_entry;
  //printf("add_libs for -%s-\n",dirname);

  dir_stream = opendir(dirname);
  if (!dir_stream){
    sprintf(error_string, "Could not open dir -%s-",dirname);
    printf("%s\n",error_string);
    return true;
  }

  while ( (dir_entry = readdir(dir_stream)) ){
    //printf("hepp %s\n",dir_entry->d_name);
    char *extension = strrchr(dir_entry->d_name, '.');
    if (extension && !strcmp(extension, ".pd_linux")){
      char temp[1024];
      char *classname = get_classname(dir_entry->d_name, temp);

      if (in_libs(*libs, classname))
        continue;

      //printf("Adding classname \"%s\"\n", classname);

      {
        lib_t *lib = calloc(1,sizeof(lib_t));

        lib->classname = (const char*)strdup(classname);

        lib->org_filename = malloc(strlen(dirname) + 5 + strlen(dir_entry->d_name));
        sprintf((char*)lib->org_filename, "%s/%s",dirname,dir_entry->d_name);

        char temp2[1024];
        sprintf(temp2, "%s", get_unique_temp_string(temp, ".so"));
        if (write_file_to_tempfile(lib->org_filename, temp2)==false)
          return false;

        lib->copy_filename = (const char*)strdup(temp2);

        lib->symname = (const char*)strdup(get_symname(lib->classname, temp));

        //printf("filename: -%s-\n",lib->org_filename);
        
        lib->next = *libs;
        *libs = lib;
      }
    }
  }

  closedir (dir_stream);

  return true;
}

void free_libs(lib_t *libs){
  while(libs != NULL) {
    lib_t *temp = libs->next;
    unlink(libs->copy_filename);
    free((char*)libs->org_filename);
    free((char*)libs->copy_filename);
    free((char*)libs->classname);
    free((char*)libs->symname);
    free(libs);
    libs = temp;
  }
}

bool create_custom_loader_source(char *template, const lib_t *libs){
  int fd = mkstemps(template,2);
  FILE *file = fdopen(fd, "a");

  if(fd==-1 || file==NULL) {
    sprintf(error_string,"Unable to create temporary file \"%s\". (%s)",template,strerror(errno));
    return false;
  }

  fprintf(file, "#include <stdlib.h>\n");
  fprintf(file, "#include <stdio.h>\n");
  fprintf(file, "#include <stdbool.h>\n");
  fprintf(file, "#include <string.h>\n");
  fprintf(file, "void post(const char *fmt, ...);\n");

  lib_t *libs2 = (lib_t*)libs;
  while(libs2 != NULL) {
    fprintf(file, "void %s(void);\n", libs2->symname);
    libs2 = libs2->next;
  }

  fprintf(file, "int libpd_load_lib(char *classname){\n");

  libs2 = (lib_t*)libs;
  while(libs2 != NULL) {
    fprintf(file, " static bool %s_loaded = false; \n",libs2->symname);
    fprintf(file, " if(!strcmp(classname, \"%s\")) {if (%s_loaded==false) {%s(); %s_loaded=true;return 1;} else return 0;}\n", libs2->classname,libs2->symname,libs2->symname,libs2->symname);
    libs2 = libs2->next;
  }
  fputs(        " post(\"\\\"\%s\\\" not found in path when libpds_create was called.\\n\", classname);\n", file);
  fprintf(file, " return 0;\n");
  fprintf(file, "};\n");

  if(fclose(file)==EOF) {
    sprintf(error_string,"Unable to write to temporary file \"%s\". (%s)",template,strerror(errno));
    return false;
  }

  return true;
}

static bool link_library(char *unlibered, char *libered, char *loader_filename, lib_t *libs){
  int size=1600;
  char *temp = malloc(size);

  sprintf(temp,"gcc -Wall -shared -o %s %s -fPIC -Xlinker -start-group %s ",libered,loader_filename, unlibered);
  while(libs != NULL) {
    int new_len = strlen(temp) + strlen(" ") + strlen(libs->copy_filename) + 10;
    if(new_len > size) {
      size = new_len * 2;
      temp=realloc(temp, size);
    }

    //printf("libs->org_filename: -%s-\n",libs->org_filename);

    strcat(temp, " ");
    strcat(temp, libs->copy_filename);

    libs=libs->next;
  }

  strcat(temp, " -end-group");
  //printf("Running -%s-\n",temp);

  if(system(temp)!=0) {
    printf("libpd: Was trying to run command \"%s\"\n",temp);
    sprintf(error_string,"Execution of gcc failed. Couldn't link file \"%s\". See terminal output for more info about what went wrong.", libered);
    free(temp);
    return false;
  }

  free(temp);
  return true;
}

static bool get_preferences_value(FILE *file, char *key, char *ret){
  char temp[1024];
  rewind(file);
  while(fgets(temp, sizeof(temp)-1, file) != NULL)
    if(!strncmp(temp, key, strlen(key))){
      char *pos = temp + strlen(key);
      while(pos[0]==' ')
        pos++;
      strcpy(ret, pos);
      ret[strlen(ret)-1] = 0; // remove newline
      return true;
    }
  return false;
}

static bool get_searchpaths(searchpath_t **sp, const char *libdir){
  char temp[1024];

  *sp=calloc(1,sizeof(searchpath_t));
  sprintf(temp, "%s/extra/vanilla/", libdir);
  (*sp)->path=(const char*)strdup(temp);

#define ADD_EXTRA(WHERE) { \
    searchpath_t *extra = calloc(1,sizeof(searchpath_t));       \
    sprintf(temp, "%s/extra/" WHERE "/", libdir);           \
    extra->path=(const char*)strdup(temp);                      \
    extra->next = *sp;                                          \
    *sp = extra;                                                \
  }

  ADD_EXTRA("bonk~");
  ADD_EXTRA("choice");
  ADD_EXTRA(""); // expr~
  ADD_EXTRA("fiddle~");
  ADD_EXTRA("loop~");
  ADD_EXTRA("lrshift~");
  //  ADD_EXTRA("pd~");
  ADD_EXTRA("pique");
  ADD_EXTRA("sigmund~");
  ADD_EXTRA("stdout");

  {
    sprintf(temp,"%s/.pdextended",getenv("HOME"));
    FILE *file=fopen(temp, "r");
    if(file==NULL){
      printf("no preferences file \"%s\"\n", temp);
      return true;
    }
  
    if(get_preferences_value(file, "npath:", temp)==false)
      goto exit;

    int num_paths = atoi(temp);
    int i;
  
    for(i=0;i<num_paths;i++){
      char key[1024];
      sprintf(key, "path%d:", i+1);
      if(get_preferences_value(file, key, temp)==true) {
        searchpath_t *new_sp = calloc(1,sizeof(searchpath_t));
        new_sp->path=(const char*)strdup(temp);
        new_sp->next = *sp;
        *sp = new_sp;
      }
    }

  exit:
    fclose(file);
    return true;

  failed:
    fclose(file);
    return false;
  }
}

static bool add_all_libs(lib_t **libs, searchpath_t *sp){
  char temp[1024];

  while(sp!=NULL){
    if(add_libs(libs, sp->path)==false)
      return false;
    sp=sp->next;
  }

  return true;
}

static void add_all_searchpaths(pd_t *pd, searchpath_t *sp){
  while(sp!=NULL){
    libpds_add_to_search_path(pd, sp->path);
    sp=sp->next;
  }
}

static void free_searchpaths(searchpath_t *sp){
  while(sp != NULL) {
    searchpath_t *temp = sp->next;
    free((char*)sp->path);
    free(sp);
    sp=temp;
  }
}

pd_t *libpds_create(bool use_gui, const char *libdir){
  //print_all("/home/kjetil/temp/pd-extended/externals/build/lib/pd-extended/extra/vanilla/");
  char temp[1024];

  pd_t *pd = calloc(1, sizeof(pd_t));

  searchpath_t *sp=NULL;
  if(get_searchpaths(&sp, libdir)==false)
    return NULL;

  lib_t *libs=NULL;
  if(add_all_libs(&libs, sp)==false)
    return NULL;

  char unlibered_filename[1024];
  sprintf(unlibered_filename, "%s", get_unique_temp_string(temp, ".so"));
  if (write_libpd_so_to_tempfile(unlibered_filename)==false)
    return NULL;

  char libered_filename[1024];
  sprintf(libered_filename, "%s", get_unique_temp_string(temp, ""));
  if(!strcmp("", mktemp(libered_filename))){
    sprintf(error_string, "Unable to create temporary filename.");
    return NULL;
  }

  char loader_filename[1024];
  sprintf(loader_filename, "%s", get_unique_temp_string(temp, ".c"));
  if (!create_custom_loader_source(loader_filename, libs))
    return NULL;
  
  if(link_library(unlibered_filename, libered_filename, loader_filename, libs)==false)
    return NULL;

  pd->handle = dlopen(libered_filename, RTLD_NOW | RTLD_LOCAL);
  if (!pd->handle) {
    sprintf(error_string, "Unable to create libpds instance. Error message: \"%s\" Filename: %s", dlerror(), libered_filename);
    fprintf(stderr, "%s\n", error_string);
    return NULL;
  }

  load_symbols(pd);

  unlink(loader_filename);
  unlink(libered_filename);
  unlink(unlibered_filename);

  free_libs(libs);
  
  if (pd->libpd_init(use_gui, libdir)==false) {
    dlclose(pd->handle);
    free(pd);
    sprintf(error_string, "libpd_init returned false. (Likely that the GUI couldn't be started).");
    return NULL;
  }

  add_all_searchpaths(pd, sp);
  free_searchpaths(sp);

  return pd;
}

// Not threadsafe. If having several errors at once, the function could return strange result.
char *libpds_strerror(void) {
  return error_string;
}

void libpds_delete(pd_t *pd) {
  pd->libpd_cleanup();
  dlclose(pd->handle);
  free(pd);
}

